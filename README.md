# Orders Bench - Паттерны конкурентности в Go

**⚠️ Важное замечание:** Этот код не является показателем того, как нужно проектировать сервис в продакшене. Он создан исключительно для демонстрации различных паттернов конкурентности в Go и их композиции. В реальных проектах архитектура должна быть более продуманной и учитывать множество других факторов.

## Описание проекта

Этот проект демонстрирует различные паттерны конкурентности в Go на примере обработки заказов. Каждый паттерн показывает разные подходы к параллельной обработке данных и их влияние на производительность.

## Модель данных

```go
type Order struct {
    ID    int
    State State
}

type State int

const (
    StateCreated State = iota
    StateStarted
    StateProcessed
    StateCompleted
)
```

## Паттерны конкурентности

### 1. Semaphore (Семафор)
**Расположение:** `internal/infra/semaphore/semaphore.go`

**Смысл:** Семафор ограничивает количество одновременно выполняющихся операций. Это классический паттерн для контроля доступа к ограниченному ресурсу.

**Принцип работы:**
- Создает канал с буфером заданного размера
- `Acquire()` блокирует выполнение, если канал полный
- `Release()` освобождает слот в канале

**Применение:** Ограничение количества одновременных HTTP-запросов, работы с базой данных, файловых операций.

### 2. Pipeline (Конвейер)
**Расположение:** `internal/infra/pipeline/pipeline.go`

**Смысл:** Pipeline позволяет организовать последовательную обработку данных через цепочку операций, где каждая стадия принимает выход предыдущей как вход.

**Принцип работы:**
- Каждая стадия обрабатывает данные последовательно
- Данные передаются через каналы между стадиями
- Обеспечивает потоковую обработку без накопления всех данных в памяти

**Применение:** Обработка данных в несколько этапов, ETL-процессы, валидация и трансформация данных.

### 3. Fan-Out/Fan-In
**Расположение:** `internal/infra/fan/fan.go`

**Смысл:** Fan-Out создает несколько параллельных обработчиков для одной стадии, а Fan-In объединяет результаты обратно в один поток.

**Принцип работы:**
- Fan-Out: создает несколько горутин для параллельной обработки
- Fan-In: собирает результаты из всех горутин в один канал
- Позволяет распараллелить трудоемкие операции

**Применение:** Параллельная обработка CPU-интенсивных задач, загрузка данных из нескольких источников.

### 4. Worker Pool (Пул воркеров)
**Расположение:** `internal/infra/workerpool/workerpool.go`

**Смысл:** Worker Pool создает фиксированное количество горутин, которые обрабатывают задачи из общей очереди.

**Принцип работы:**
- Создает фиксированное количество горутин-воркеров
- Воркеры берут задачи из входного канала
- Результаты отправляются в выходной канал
- Эффективно использует ресурсы системы

**Применение:** Обработка HTTP-запросов, работа с базой данных, обработка файлов.

### 5. Generator (Генератор)
**Расположение:** `internal/infra/generator/generator.go`

**Смысл:** Генератор создает поток данных по требованию, не загружая все данные в память одновременно.

**Принцип работы:**
- Создает канал и горутину для генерации данных
- Данные генерируются и отправляются в канал по мере необходимости
- Позволяет работать с большими объемами данных

**Применение:** Чтение больших файлов, генерация тестовых данных, стриминг данных.

## Примеры использования

### 00_semaphore
**Производительность:** Демонстрирует ограничение количества одновременных горутин
- Ограничивает количество одновременно выполняющихся операций до 2
- Показывает, как семафор контролирует доступ к ресурсам

### 01_base (Базовый подход)
**Производительность:** ~80 секунд
- Последовательная обработка заказов
- Каждый заказ проходит все стадии по очереди
- Самый медленный подход, но простой для понимания

### 02_pipeline (Конвейер)
**Производительность:** ~61 секунда
- Использует паттерн Pipeline для потоковой обработки
- Заказы обрабатываются по стадиям: Start → Process → Complete
- Улучшение на ~24% по сравнению с базовым подходом

### 03_pipeline_fan (Конвейер с Fan-Out)
**Производительность:** ~23 секунды
- Комбинирует Pipeline с Fan-Out на стадии Process
- Стадия Process распараллеливается на 5 горутин
- Улучшение на ~62% по сравнению с простым Pipeline

### 04_workerpool (Пул воркеров)
**Производительность:** ~16 секунд
- Использует Worker Pool для параллельной обработки
- 5 воркеров обрабатывают заказы полностью (Start → Process → Complete)
- Улучшение на ~30% по сравнению с Pipeline + Fan

### 05_workerpool_with_pipeline (Пул воркеров с конвейером)
**Производительность:** ~13 секунд
- Комбинирует Worker Pool с Pipeline внутри каждого воркера
- Каждый воркер использует Pipeline для обработки заказа
- Улучшение на ~19% по сравнению с простым Worker Pool

### 06_workerpool_with_fan_pipeline (Пул воркеров с Fan-конвейером)
**Производительность:** ~7 секунд
- Максимальная оптимизация: Worker Pool + Pipeline + Fan-Out
- Каждый воркер использует FanPipeline для обработки заказа
- Улучшение на ~46% по сравнению с Worker Pool + Pipeline

## Анализ результатов

| Подход | Время (сек) | Улучшение | Описание |
|--------|-------------|-----------|----------|
| Base | 80 | - | Последовательная обработка |
| Pipeline | 61 | 24% | Потоковая обработка |
| Pipeline + Fan | 23 | 62% | Параллелизация трудоемкой стадии |
| Worker Pool | 16 | 30% | Параллельная обработка заказов |
| Worker Pool + Pipeline | 13 | 19% | Оптимизация внутри воркеров |
| Worker Pool + Fan Pipeline | 7 | 46% | Максимальная оптимизация |